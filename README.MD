---
# Go RPS (Requests-Per-Second) Blocker

Данный проект представляет собой консольное приложение на Go, которое

1. Захватывает сетевой трафик (через [gopacket](https://github.com/google/gopacket) и [libpcap](https://www.tcpdump.org/)),  
2. Подсчитывает число пакетов в секунду (PPS/RPS) для каждого IP-адреса,  
3. Имеет белый список (whitelist) IP-адресов, которые **никогда не блокируются**,  
4. При превышении заданного порога (`threshold`) блокирует нарушителей с помощью **iptables**,  
5. Записывает заблокированные IP в отдельный файл,  
6. Может работать как со **всем** трафиком, так и с трафиком **конкретного порта** (TCP/UDP) с помощью BPF-фильтра.

### Основные пакеты / модули

- **`config`**: отвечает за загрузку конфигурации (парсинг флагов, чтение whitelist-файла и т.д.).  
- **`block`**: содержит логику блокировки IP (вызывая `iptables`), ведёт учёт уже заблокированных адресов и whitelist-адресов.  
- **`netcap`**: «сниффер», который открывает интерфейс для чтения пакетов, применяет BPF-фильтр, подсчитывает PPS и при необходимости вызывает блокировку.

> Основной файл [`main.go`](./main.go) связывает все эти части вместе.

---

## Содержание

- [Требования](#требования)  
- [Установка и сборка](#установка-и-сборка)  
- [Пример использования](#пример-использования)  
- [Параметры командной строки](#параметры-командной-строки)  
- [Белый список IP](#белый-список-ip)  
- [Как работает](#как-работает)  

---

## Требования

1. **Go 1.18+** (рекомендуется более свежая версия Go).  
2. **libpcap** (или соответствующий dev-пакет: `libpcap-dev` в Debian/Ubuntu).  
3. **root-права** (или `CAP_NET_RAW, CAP_NET_ADMIN`), так как:
   - Захват «сырого» сетевого трафика через pcap требует повышенных привилегий,  
   - Блокировка IP через iptables тоже требует прав суперпользователя (или sudo).  

---

## Установка и сборка

1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/username/go-rps-blocker.git
   cd go-rps-blocker
   ```
2. Инициализируйте и обновите зависимости Go (если нужно):
   ```bash
   go mod tidy
   ```
3. Соберите проект:
   ```bash
   go build -o rps-blocker
   ```
   В результате появится бинарный файл `rps-blocker`.

---

## Пример использования

```bash
sudo ./rps-blocker \
  -device="eth0" \
  -threshold=100 \
  -whitelist="/tmp/whitelist_ips.txt" \
  -blocked="/tmp/blocked_ips.txt" \
  -interval=1s \
  -port=80
```

- Запуск с `sudo` нужен, так как внутри требуется доступ к `iptables` и «сырым» пакетам.  
- Программа будет слушать **только** порт **80** (TCP/UDP), инкрементировать счётчик PPS от каждого IP, и если количество пакетов в секунду превысит **100**, — блокировать через iptables.

Если нужно слушать **все** порты:
```bash
sudo ./rps-blocker \
  -device="eth0" \
  -threshold=50 \
  -whitelist="/tmp/whitelist_ips.txt" \
  -blocked="/tmp/blocked_ips.txt" \
  -interval=1s \
  -port=0
```
(или просто не задавать `-port` вовсе, по умолчанию будет 0).

При желании вы можете изменить интерфейс на любой другой, например `-device="enp0s3"`.

---

## Параметры командной строки

| Параметр          | Тип           | Описание                                                                        | Значение по умолчанию               |
|-------------------|--------------|---------------------------------------------------------------------------------|--------------------------------------|
| `-device`         | string       | Сетевой интерфейс для прослушивания (eth0, enp0s3, ens33 и т.д.)                | `eth0`                               |
| `-snapshotlen`    | int          | Размер «среза» пакета в байтах для pcap                                         | `1024`                               |
| `-promisc`        | bool         | Режим promiscuous (true/false)                                                 | `true`                               |
| `-timeout`        | duration     | Таймаут для pcap (0 = BlockForever)                                             | `0` (блокирующий режим)             |
| `-threshold`      | int          | Порог (число пакетов в секунду), выше которого IP блокируется                   | `100`                                |
| `-whitelist`      | string       | Путь к файлу, где перечислены «белые» IP-адреса                                 | `/tmp/whitelist_ips.txt`            |
| `-blocked`        | string       | Путь к файлу, куда записывать заблокированные IP-адреса                         | `/tmp/blocked_ips.txt`              |
| `-interval`       | duration     | Интервал проверки счётчиков (обычно `1s`)                                       | `1s`                                 |
| `-port`           | uint         | Номер порта, который слушать. `0` = все порты                                   | `0` (слушаем всё)                    |

> `duration` означает формат вида `1s`, `500ms`, `2s` и т.д.

---

## Белый список IP

- Путь к файлу задаётся параметром `-whitelist`.  
- В файле перечисляются IP-адреса по одному в строке. Пример:
  ```
  127.0.0.1
  192.168.0.10
  8.8.8.8
  ```
- Эти IP **никогда** не будут блокироваться, даже если превышают порог.  

---

## Как работает

1. **Сбор пакетов**:  
   - Программа открывает интерфейс (через `pcap.OpenLive`), и при необходимости вешает BPF-фильтр (например, `port 80`). Если `-port=0`, то фильтр не ставится, слушаем весь трафик.  

2. **Подсчёт пакетов**:  
   - Каждый входящий пакет (IPv4) разбирается (gopacket), извлекается `srcIP`.  
   - Внутренний `map[string]int` хранит счётчики «пакетов за текущий интервал» (PPS).  
   - Адреса из whitelist и уже заблокированные адреса не учитываются в статистике.  

3. **Периодическая проверка**:  
   - Раз в `-interval` (по умолчанию 1 сек) программа смотрит, у каких IP счётчик превышает `-threshold`.  
   - Для «провинившихся» IP вызывается блокировка через `iptables -A INPUT -s <ip> -j DROP`.  
   - IP добавляется в локальный «список уже заблокированных» и записывается в файл `-blocked`.  
   - Счётчики обнуляются на следующий интервал.  

4. **Блокировка**:  
   - Используется `exec.Command("iptables", "-A", "INPUT", "-s", ip, "-j", "DROP")`.  
   - Требует прав суперпользователя.  

5. **Остановка**:  
   - При получении сигнала (Ctrl+C, SIGTERM) программа корректно останавливает сниффинг и закрывает pcap. 
